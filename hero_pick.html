<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>hero_pick</title>
	
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
	<script src="http://underscorejs.org/underscore-min.js"></script>
	
	<style type="text/css" media="screen">
		body {
		  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
		  margin: auto;
		  position: relative;
		  width: 1000px;
		}
		
		text {
		  font: 10px sans-serif;
			color: white;
		}

		text.selected {
			font-weight: bold;
		}

		
		.axis path,
		.axis line {
		  fill: none;
		  stroke: #000;
		  shape-rendering: crispEdges;
		}
		
		.axis path {
			opacity: 0;
		}
		
		.y .tick {
			stroke: #555;
			opacity: 0.4;
		  shape-rendering: crispEdges;
		}
		
		.tick.major line {
			stroke: #ccc;
		}
		
		.line {
		  stroke: #aaa;
			fill: #aaa;
			stroke-width: 1px;
		}
		
		#container {
			width: 1000px;
			margin-left: auto;
			
			padding-left: 80px;
		}
		
		#charts {
			margin-left: -80px;
		}
		
		#footer {
			margin-top: 10px;
			width: 100%;
			font-size: 0.8em;
		}
		
		#other-heroes {
			width: 730px;
			margin-left: 150px;
			font-size: 0.7em;
			color: #aaa;
			
			height: 0px;
			opacity: 0;
		}
	</style>
	<!-- Data is here. -->
	<script type="text/javascript" src="hero_picks.js"></script>
	<script type="text/javascript" src="yearweeks.js"></script>
	
	<!-- rendering is here. -->
	<script type="text/javascript" charset="utf-8">
	
		var margin = {top: 0, right: 190, bottom: 0, left: 150};
		var globalWidth = 1000;
	
		var numWeeks = 22;
		
		var matchFrequencyHeight = 100;
		
		var showNormalized = true;
		
		$("document").ready(function() {
			generateNormalizedStack();
			generateMatchHistogram();
		});
		
		function generateMatchHistogram() {
			
			margin.bottom = 40;
			
			// hell if I know why this isn't lining up but HACK TIME
			var histogramWidth = globalWidth - margin.left - margin.right -25,
			    histogramHeight = 80 - margin.top - margin.bottom;
			
			var maxPicks = d3.max(yearweeks, function(d) {return d.totalPicks/10});
			
			var svg = d3.select("#charts").append("svg")
				.attr("width", histogramWidth + margin.left + margin.right)
				.attr("height", histogramHeight + margin.top + margin.bottom)
			.append("g")
			 .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
			
			// not sure why I need this adjustment factor either but SCREW IT
			var x = d3.scale.ordinal()
				.rangeBands([0, histogramWidth+140], 0)
				.domain(_.pluck(yearweeks, "yearWeek"));
			
			var y = d3.scale.linear()
				.domain([0, maxPicks])
				.range([histogramHeight, 0]);
			
			var counter = 0;
			
			var xAxis = d3.svg.axis()
				.scale(x)
				.tickFormat(function(d) {
					d = d + "";
					var year = parseInt(d.substring(0, 4));
					var week = parseInt(d.substring(4, 6));
					
					if(counter==0) {
						counter++;
						return "Aug, " + year;
					} else if(week==1) {
						counter++;
						return "Jan, " + year;
					}
					
					counter++;
					
					return "";
				})
				.orient("bottom");
			
			var yAxis = d3.svg.axis()
				.scale(y)
				.ticks(3)
				.tickSize(-histogramWidth-20-80)
				.orient("left");
				


			var area = d3.svg.area()
						.x(function(d) {return x(d.yearWeek);})
						.y0(histogramHeight)
						.y1(function(d) {return y(d.totalPicks/10)});
			
			svg.append("path")
						.datum(yearweeks)
						.attr("class", "line")
						.attr("d", area);
						
						svg.append("g")
							.attr("class", "y axis")
							.call(yAxis);
							svg.append("g")
								.attr("class", "x axis")
								.attr("transform", "translate(-20,"+histogramHeight + ")")
								.call(xAxis);

				svg.append("text")
				    .attr("class", "y label")
				    .attr("text-anchor", "end")
						.style("font-size", "1.0em")
				    .attr("y", 50)
						.attr("x", 400)
				    .attr("dy", ".75em")
				    .text("matches per week");
			
		}
		
		function generateNormalizedStack() {
			
			// erg this is bad to have here but...
			margin.top = 10;
			margin.bottom = 0;
			
			var width = globalWidth - margin.left - margin.right;
			var height = 700 - margin.top - margin.bottom;
			
			var gpmRangeColors = ["#4B7A45", "#efe"];
			
			var svg = d3.select("#charts").append("svg")
					.attr("width", width + margin.left + margin.right)
					.attr("height", height + margin.top + margin.bottom)
					.append("g")
				 		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
				
				var x = d3.scale.linear()
				    .domain([0, numWeeks - 1])
				    .range([0, globalWidth - margin.right]);

				var y = d3.scale.linear()
				    .domain([0, 1])
				    .range([height, 0]);

				var color = d3.scale.linear()
				    .range(gpmRangeColors);
						
				var area = d3.svg.area()
				    .x(function(d) { return x(d.x); })
				    .y0(function(d) { return y(d.y0); })
				    .y1(function(d) { return y(d.y0 + d.y); });
				
				// TODO convert this to d3 max/min finding
				// beware, these numbers aren't actually GPM values, they're
				// the sum of total GPM across all games.
				var gpmRange = [1000, 0];
				_.each(heroes, function(hero) {
					if(hero.gpm < gpmRange[0]) gpmRange[0] = hero.gpm;
					if(hero.gpm > gpmRange[1]) gpmRange[1] = hero.gpm;
				});
				
				console.log("gpmRange: " + JSON.stringify(gpmRange));
				
			var stack = d3.layout.stack()
				.offset("expand")
				.order(function(data) {
					return d3.range(data.length);
				})
				.values(function(d) { return d.values;});
			
			var layers = stack(heroes);
			_.each(heroes, function(hero) {
				var peakWidth = 0;
				var index = 0;
				var justSetPeakWidth = false;
				_.each(hero.values, function(value) {
					
					
					// this is a weird exception for morphling, where he goes to zero
					// the week after his peak, which ruins the algorithm. Shift his
					// peak week back a bit. But make sure you don't do this for heroes
					// on the left edge. 
					if(justSetPeakWidth) {
						
						if(value.y==0 && index>1) {
							hero.peakWeek = hero.peakWeek-1;
						}
						
						justSetPeakWidth = false;
					}
					
					if(value.y > peakWidth) {
						hero.peakWeek = index;
						hero.peakWidth = value.y;
						hero.peakWeekFixed = true;
						peakWidth = value.y;
						
						// do a check to see if the next width is zero
						justSetPeakWidth = true;
					}
					
					index++;
				});
				
				if(hero.peakWidth < 0.017) {
					hero.peakWeek = 0;
				}
			});
			
			var defs = svg.append("svg:defs");
			
			var gradient = defs.append("svg:linearGradient")
					.attr("id", "gradient")
					.attr("x1", "0%")
					.attr("y1", "0%")
					.attr("x2", "0%")
					.attr("y2", "100%")
					.attr("spreadMethod", "pad");
			gradient.append("svg:stop")
				.attr("offset", "0%")
				.attr("stop-color", gpmRangeColors[1])
				.attr("stop-opacity", 1);

				gradient.append("svg:stop")
					.attr("offset", "100%")
					.attr("stop-color", gpmRangeColors[0])
					.attr("stop-opacity", 1);

			var hashGradient = defs.append("svg:linearGradient")
					.attr("id", "hash")
					.attr("x1", "0%")
					.attr("y1", "0%")
					.attr("x2", "0%")
					.attr("y2", "140%")
					.attr("spreadMethod", "pad")
					.attr("gradientTransform", "rotate(-50)");
					
			var hashColors = ["#9abb97", "#7ca277"];
			var toggle = 0;
			for(var i=0; i<20; i++) {
				hashGradient.append("svg:stop")
					.attr("offset", (i*5) + "%")
					.attr("stop-color", hashColors[toggle])
					.attr("stop-opacity", 1);
				hashGradient.append("svg:stop")
						.attr("offset", ((i+1)*5) + "%")
						.attr("stop-color", hashColors[toggle])
						.attr("stop-opacity", 1);
				if(toggle==0) {
					toggle=1;
				} else {
					toggle=0;
				}
			}

			var gpmLegend = svg.append("g");
			
					gpmLegend.attr("class", "legend")
						.append("rect")
							.attr("x", -80)
							.attr("y", 0)
							.attr("width", 20)
							.attr("height", 100)
							.attr("fill", "url(#gradient)");
							
					
					// assuming that GPM is always 3 digits here, which is (for now)
					// a safe bet. highest average we see in pro games is 500. Not sure
					// you can go much lower than 100 credibly. 
					gpmLegend.append("text")
							.attr("x", -82)
							.attr("y", 8)
							.attr("text-anchor", "end")
							.text((gpmRange[1]+"").slice(0, 3) + " GPM");
							
					gpmLegend.append("text")
							.attr("x", -82)
							.attr("y", 100)
							.attr("text-anchor", "end")
							.text((gpmRange[0]+"").slice(0, 3) + " GPM")
			
			
			var colorHero = function(d) {
				
				if("isOtherHero" in d) {
					return "url(#hash)";
				}
				
				// normalize based on what GPMs we see in the data
				return color((d.gpm-gpmRange[0])/gpmRange[1]);
			}
			
			var mouseoverHero = function(id) {
				var path = svg.select("path#hero-" + id);
				var d = _.find(heroes, function(hero) { return hero.heroId==id;});
				
				path.style("opacity", "0.5");
				
				var text = svg.select("text#label-" + id);
				text.attr("class", "hero-name selected")
				
				if(_.isUndefined(id)) {
					// we're over the "others" row
					// animate in the extra info div.
					
					$("#other-heroes").show();
					$("#other-heroes").animate({opacity:1, height: "30px"}, 200);
					
				}
			}
			
			var mouseoutHero = function(id) {
				var path = svg.select("path#hero-" + id);
				
				var d = _.find(heroes, function(hero) { return hero.heroId==id;});
				
				// path.style("fill", colorHero(d));
				path.style("opacity", "1");

				var text = svg.select("text#label-" + id);
				text.attr("class", "hero-name");
				
				if(_.isUndefined(id)) {
					// we're over the "others" row
					// animate in the extra info div.
					$("#other-heroes").animate({opacity:0, height: "0px"},200, "swing", 
					function(){
						$(this).hide();
					});
				}
				
			}
			
			var path = svg.append("g")
					.attr("class", "paths")
					.selectAll("path")
						.data(layers)
					.enter().append("path")
						.attr("d", function(d) { return area(d.values)})
						.attr("id", function(d) {
							return "hero-" + d.heroId;
						})
						.style("fill", colorHero)
						.on("mouseover", function(d) {
							mouseoverHero(d.heroId);
						})
						.on("mouseout", function(d) {
							mouseoutHero(d.heroId);
						});
			
			
			var textY = function(d) {
					var points = getPathPointsForWeek(d.heroId, d.peakWeek);
					
					var width =  points[1].y - points[0].y;
					
					// get the position of the upper line (extract from the raw
					// path listing, shifted by one because the first seg is
					// always an absolute move command) and then add on half
					// the width of the bar at that point.
					return points[0].y + width/2 + 3;
			}
			
			var text = svg.append("g")
					.attr("class", "hero-name")
					.selectAll("text")
						.data(layers)
					.enter().append("text")
							.attr("id", function(d) {
								return "label-"+d.heroId;
							})
							.attr("y", textY)
							.attr("x", function(d) {
								return x(d.peakWeek);
							})
							.on("mouseover", function(d) {
								mouseoverHero(d.heroId);
							})
							.on("mouseout", function(d) {
								mouseoutHero(d.heroId);
							})
							.attr("text-anchor", function(d) {
								if(d.peakWeek==0) {
									return "end";
								} else if (d.peakWeek>=(numWeeks-3)) {
									return "start";
								} else {
									return "start";
								}
							})
							.attr("transform", function(d) {
								// check to see if the peak week is at the start or end of the
								// set.
								console.log(d.peakWeek);
								if(d.peakWeek==0) {
									return "";
								} else if (d.peakWeek>=(numWeeks-3)) {
									return "";
								} else {
									var firstPoints = getPathPointsForWeek(d.heroId, d.peakWeek);
									var secondPoints = getPathPointsForWeek(d.heroId, d.peakWeek+1);
								
									var centerPointsY = [(firstPoints[0].y + firstPoints[1].y)/2,
									(secondPoints[0].y + secondPoints[1].y)/2];
									// var centerPointsY = [firstPoints[1].y, secondPoints[1].y];
								
									// console.log(d.heroName);
									// console.log("rise: " + (centerPointsY[1] - centerPointsY[0]));
									// console.log("run: " + (secondPoints[0].x - firstPoints[0].x));
									// 
									// console.log("firstPoints: " + JSON.stringify(firstPoints));
									// console.log("secondPoints: " + JSON.stringify(secondPoints));

								
									var angle = Math.atan((centerPointsY[1] - centerPointsY[0])/ (secondPoints[0].x - firstPoints[0].x))/Math.PI*180;
								
									return "rotate(" +angle+ " " + x(d.peakWeek) +","+textY(d) + ")";
								}
							})
						  .text(function(d) { return d.heroName; });
						
						
						// populate the #other-heroes div with a list of other hero picks.
						var otherHeroesInfo = heroes[0];
						
						console.log(JSON.stringify(heroes[0]));
						var otherHeroesInfoDiv = $("<div id='other-heroes'></div>");
						otherHeroesInfoDiv.text(otherHeroesInfo.names.join(", "));
						
						$("#charts").append(otherHeroesInfoDiv);
						
						otherHeroesInfoDiv.hide();
		}
		
		function getPathPointsForWeek(heroId, week) {
			// okay shit is going to get real here.
			// pull the path object from SVG
			var path = document.getElementById("hero-" + heroId);
			
			// now get the points
			var segs = path.pathSegList;
			
			var upperPoint = segs.getItem(week);
			// lower point will be the only other one with the same x
			var lowerPoint;
			
			// start at one beyond the upper point's index
			for(var i=week+1; i<segs.numberOfItems; i++) {
				if(segs.getItem(i).x==upperPoint.x) {
					lowerPoint = segs.getItem(i);
					break;
				}
			}
			
			return [upperPoint, lowerPoint];
		}
	</script>
</head>
<body id="hero_pick" onload="">
	<div id="container">
	<h1>Dota2 Season 3 Professional Hero Picks</h1>
	<p>Some explanatory text goes here.</p>
	<div id="charts">
	<div id="footer">
		Designed and programmed by Drew Harry. Data courtesy of <a href="http://datdota.com/">DatDota</a>. 
	</div>
	</div>
	
</body>
</html>